<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>newapi OpenAI 代理 · 模型覆写控制台</title>
    <style>
      :root {
        --bg: #0e1117;
        --panel: #161b22;
        --accent: #00c2ff;
        --accent-2: #9d6bff;
        --text: #e6edf3;
        --muted: #9ca3af;
        --border: #30363d;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background:
          radial-gradient(circle at 10% 20%, rgba(0, 194, 255, 0.12), transparent 35%),
          radial-gradient(circle at 80% 0%, rgba(157, 107, 255, 0.18), transparent 35%),
          var(--bg);
        color: var(--text);
        min-height: 100vh;
        padding: 24px 16px;
        display: flex;
        justify-content: center;
      }
      .shell {
        width: min(1180px, 100%);
        background: rgba(22, 27, 34, 0.95);
        border-radius: 16px;
        border: 1px solid var(--border);
        padding: 18px 18px 20px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
        display: flex;
        flex-direction: column;
        gap: 14px;
      }
      header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
        flex-wrap: wrap;
      }
      .title {
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .pill {
        padding: 2px 8px;
        border-radius: 999px;
        border: 1px solid rgba(0, 194, 255, 0.4);
        background: rgba(0, 194, 255, 0.12);
        color: var(--accent);
        font-size: 12px;
      }
      .row {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
        gap: 8px;
      }
      .panel {
        border-radius: 12px;
        border: 1px solid var(--border);
        background: #0d1117;
        padding: 12px 12px 10px;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .panel-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
        font-size: 13px;
        color: var(--muted);
      }
      label {
        font-size: 13px;
        color: var(--muted);
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      input,
      select {
        width: 100%;
        border-radius: 8px;
        border: 1px solid var(--border);
        background: #010409;
        color: var(--text);
        font-size: 13px;
        padding: 7px 9px;
        outline: none;
      }
      input:focus,
      select:focus {
        border-color: var(--accent);
        box-shadow: 0 0 0 2px rgba(0, 194, 255, 0.2);
      }
      textarea {
        width: 100%;
        border-radius: 8px;
        border: 1px solid var(--border);
        background: #010409;
        color: var(--text);
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono",
          "Courier New", monospace;
        font-size: 12px;
        padding: 7px 9px;
        resize: vertical;
        outline: none;
      }
      .layout {
        display: grid;
        grid-template-columns: minmax(0, 1.4fr) minmax(0, 2fr);
        gap: 10px;
      }
      .models-list {
        max-height: 420px;
        overflow: auto;
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .model-row {
        display: flex;
        gap: 4px;
        align-items: center;
      }
      .model-item {
        flex: 1;
        text-align: left;
        border-radius: 8px;
        border: 1px solid var(--border);
        background: #0a0f16;
        color: var(--text);
        font-size: 13px;
        padding: 7px 9px;
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
      }
      .model-item span.meta {
        font-size: 11px;
        color: var(--muted);
      }
      .model-item.alias {
        border-color: rgba(0, 194, 255, 0.5);
        background: rgba(0, 194, 255, 0.08);
      }
      .model-item.active {
        box-shadow: 0 0 0 1px var(--accent);
      }
      .note {
        font-size: 12px;
        color: var(--muted);
      }
      .log-box {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono",
          "Courier New", monospace;
        font-size: 12px;
        background: #010409;
        border-radius: 8px;
        border: 1px solid var(--border);
        padding: 6px 8px;
        max-height: 120px;
        overflow: auto;
        color: #9ca3af;
      }
      .status-line {
        font-size: 12px;
        color: var(--muted);
      }
      button {
        border-radius: 8px;
        border: 1px solid rgba(148, 163, 184, 0.6);
        background: #111827;
        color: var(--text);
        font-size: 13px;
        padding: 6px 10px;
        cursor: pointer;
      }
      button.secondary {
        border-color: rgba(0, 194, 255, 0.6);
        color: var(--accent);
      }
      button.danger {
        border-color: rgba(248, 113, 113, 0.8);
        color: #fecaca;
      }
      button:hover {
        background: #020617;
      }
    </style>
  </head>
  <body>
    <div class="shell">
      <header>
        <div class="title">
          <span>newapi OpenAI 代理覆写面板</span>
          <span class="pill">Thinking · 渠道 · 重定向</span>
        </div>
        <div class="row" style="grid-template-columns: minmax(0, 1.5fr) minmax(0, 1.1fr) auto">
          <label>
            代理地址
            <input id="endpoint" placeholder="默认：当前域名或 http://localhost:14300" />
          </label>
          <label>
            代理密钥（PROXY_API_KEY，可选）
            <input id="proxyKey" placeholder="用于保护代理访问" />
          </label>
          <div style="display: flex; align-items: flex-end; gap: 6px">
            <button id="refreshModelsBtn" class="secondary">刷新模型</button>
            <button id="reloadConfigBtn" class="secondary">刷新配置</button>
          </div>
        </div>
      </header>

      <div class="layout">
        <section class="panel">
          <div class="panel-header">
            <span>模型列表</span>
            <span class="note">按渠道分组展示上游模型与代理别名，可手动隐藏/删除</span>
          </div>
          <div class="row">
            <label>
              模型来源渠道筛选
              <select id="modelsChannelFilter">
                <option value="">全部渠道</option>
              </select>
            </label>
          </div>
          <div id="modelsBox" class="models-list">
            <div class="note">点击右上角“刷新模型”拉取 /v1/models</div>
          </div>
        </section>

        <section class="panel">
          <div class="panel-header">
            <span>当前别名 / 重定向设置</span>
            <span id="currentSettingsLine" class="note">未选择模型</span>
          </div>
          <div class="row">
            <label>
              客户端模型 ID（别名，必填）
              <input
                id="settingsModelId"
                placeholder="例如：claude-sonnet-4-常用 / claude-sonnet-4-备用"
              />
            </label>
          </div>
          <div class="row">
            <label>
              目标模型 ID（上游实际模型名，必填）
              <input id="settingsTargetModel" placeholder="例如：claude-sonnet-4（必填）" />
            </label>
          </div>
          <div class="row">
            <label>
              渠道标识（必填，别名与渠道成对绑定）
              <input
                id="settingsChannel"
                list="channelOptions"
                placeholder="例如：newapi / copilot"
              />
              <datalist id="channelOptions"></datalist>
            </label>
          </div>
          <div class="note">
            <strong>多渠道同名模型重定向：</strong>例如 newapi 与 copilot 渠道中都存在
            <code>claude-sonnet-4</code>，可以分别设置别名：
            <code>claude-sonnet-4-常用</code>（渠道 newapi），
            <code>claude-sonnet-4-备用</code>（渠道 copilot）。客户端只需调用别名即可走不同渠道。
          </div>
          <div class="note">
            <strong>Thinking 覆写说明：</strong><br />
            - 请求体中 <code>thinking.type = "enabled"</code> 且有
            <code>budget_tokens</code> 时，代理会自动追加 antml 思考系统提示词（长度 =
            <code>budget_tokens × 5</code>）；<br />
            - 流式响应中的 <code>&lt;thinking&gt;</code> 标签会被覆写为
            <code>&lt;think&gt;</code>；<br />
            - 未启用 thinking 时，只做模型重定向与渠道选择，不做额外替换。
          </div>
          <div style="display: flex; justify-content: flex-end; gap: 8px; margin-top: 6px">
            <button id="newAliasBtn" class="secondary">新建别名</button>
            <button id="deleteAliasBtn" class="danger">删除当前别名</button>
            <button id="saveSettingsBtn">保存当前别名设置</button>
          </div>
        </section>
      </div>

      <section class="panel">
        <div class="panel-header">
          <span>渠道配置（上游地址与密钥）</span>
          <span class="note">与环境变量 UPSTREAM_CHANNELS 双向同步</span>
        </div>
        <div id="channelList" class="note">暂无渠道</div>
        <div class="row">
          <label>
            渠道名称
            <input id="newChannelName" placeholder="例如：newapi / copilot" />
          </label>
          <label>
            上游地址 base_url
            <input id="newChannelBaseUrl" placeholder="例如：https://api.xxx.com" />
          </label>
          <label>
            上游密钥 api_key
            <input id="newChannelKey" placeholder="例如：sk-xxxx" />
          </label>
          <div style="display: flex; align-items: flex-end">
            <button id="addChannelBtn" class="secondary">添加 / 更新渠道</button>
          </div>
        </div>
      </section>

      <section class="panel">
        <div class="panel-header">
          <span>覆写配置预览</span>
          <span class="note">结构等同于 /overrides 与环境变量 MODEL_OVERRIDE_MAP</span>
        </div>
        <textarea id="configPreview" readonly style="min-height: 140px"></textarea>
        <div class="note">
          可将此 JSON 复制到服务端环境变量 <code>MODEL_OVERRIDE_MAP</code> 中，以便在无本地文件时也能恢复配置。
        </div>
      </section>

      <section class="panel">
        <div class="panel-header">
          <span>日志</span>
        </div>
        <div id="logBox" class="log-box"></div>
        <div id="statusLine" class="status-line"></div>
      </section>
    </div>

    <script>
      const endpointInput = document.getElementById("endpoint");
      const proxyKeyInput = document.getElementById("proxyKey");
      const refreshModelsBtn = document.getElementById("refreshModelsBtn");
      const reloadConfigBtn = document.getElementById("reloadConfigBtn");
      const modelsChannelFilter = document.getElementById("modelsChannelFilter");
      const modelsBox = document.getElementById("modelsBox");
      const settingsModelId = document.getElementById("settingsModelId");
      const settingsTargetModel = document.getElementById("settingsTargetModel");
      const settingsChannel = document.getElementById("settingsChannel");
      const channelOptions = document.getElementById("channelOptions");
      const saveSettingsBtn = document.getElementById("saveSettingsBtn");
      const newAliasBtn = document.getElementById("newAliasBtn");
      const deleteAliasBtn = document.getElementById("deleteAliasBtn");
      const configPreview = document.getElementById("configPreview");
      const logBox = document.getElementById("logBox");
      const statusLine = document.getElementById("statusLine");
      const currentSettingsLine = document.getElementById("currentSettingsLine");
      const channelList = document.getElementById("channelList");
      const newChannelName = document.getElementById("newChannelName");
      const newChannelBaseUrl = document.getElementById("newChannelBaseUrl");
      const newChannelKey = document.getElementById("newChannelKey");
      const addChannelBtn = document.getElementById("addChannelBtn");

      const defaultOrigin = window.location.origin.startsWith("http")
        ? window.location.origin
        : "http://localhost:14300";

      let modelsCache = [];
      let modelSettings = {}; // { aliasId: { targetModel, channel } }
      let upstreamChannels = {}; // { name: { base_url, api_key } }
      let currentBaseModelId = ""; // 当前选中条目的上游模型 ID（alias_for 或自身）
      let currentEditingModelId = ""; // 打开设置时的别名 ID，用于“重命名”时删除旧 key
      // 隐藏模型配置（仅前端本地，按“渠道+模型 ID”成对记录）
      let hiddenModels = new Set();

      function log(msg) {
        const now = new Date().toLocaleTimeString();
        const div = document.createElement("div");
        div.textContent = `[${now}] ${msg}`;
        logBox.appendChild(div);
        logBox.scrollTop = logBox.scrollHeight;
      }

      function setStatus(text) {
        statusLine.textContent = text || "";
        if (text) log(text);
      }

      function buildHeaders() {
        const headers = { "Content-Type": "application/json" };
        const key = proxyKeyInput.value.trim() || localStorage.getItem("proxy_key") || "";
        if (key) headers["Authorization"] = `Bearer ${key}`;
        return headers;
      }

      function currentEndpoint() {
        return endpointInput.value.trim() || localStorage.getItem("proxy_endpoint") || defaultOrigin;
      }

      function saveEndpointAndKey() {
        const ep = endpointInput.value.trim() || defaultOrigin;
        const key = proxyKeyInput.value.trim();
        localStorage.setItem("proxy_endpoint", ep);
        localStorage.setItem("proxy_key", key);
      }

      function hydrateEndpointAndKey() {
        const ep = localStorage.getItem("proxy_endpoint") || defaultOrigin;
        const key = localStorage.getItem("proxy_key") || "";
        endpointInput.value = ep;
        proxyKeyInput.value = key;
      }

      function loadHiddenModels() {
        try {
          const raw = localStorage.getItem("hidden_models") || "[]";
          const arr = JSON.parse(raw);
          if (Array.isArray(arr)) {
            hiddenModels = new Set(arr);
          } else {
            hiddenModels = new Set();
          }
        } catch {
          hiddenModels = new Set();
        }
      }

      function saveHiddenModels() {
        try {
          localStorage.setItem("hidden_models", JSON.stringify(Array.from(hiddenModels)));
        } catch {
          // 忽略本地存储错误
        }
      }

      function renderChannels() {
        const entries = Object.entries(upstreamChannels || {});
        if (!entries.length) {
          channelList.textContent = "暂无渠道，请在下方添加。";
        } else {
          channelList.textContent = entries
            .map(([name, cfg]) => `${name} (${cfg.base_url || "未配置地址"})`)
            .join(" · ");
        }

        // 渠道选择（别名编辑用）
        channelOptions.innerHTML = "";
        // 渠道筛选（模型列表用）
        modelsChannelFilter.innerHTML = "";
        const allOpt = document.createElement("option");
        allOpt.value = "";
        allOpt.textContent = "全部渠道";
        modelsChannelFilter.appendChild(allOpt);

        entries.forEach(([name]) => {
          const opt = document.createElement("option");
          opt.value = name;
          opt.textContent = name;
          modelsChannelFilter.appendChild(opt);

          const opt2 = document.createElement("option");
          opt2.value = name;
          channelOptions.appendChild(opt2);
        });
      }

      async function fetchChannels() {
        const endpoint = currentEndpoint();
        try {
          const resp = await fetch(`${endpoint}/channels`, { headers: buildHeaders() });
          const data = await resp.json();
          if (!resp.ok) throw new Error(JSON.stringify(data));
          upstreamChannels = data.channels || {};
          renderChannels();
        } catch (err) {
          setStatus(`获取渠道失败：${err}`);
        }
      }

      async function saveChannelsToServer(channelsObj) {
        const endpoint = currentEndpoint();
        const resp = await fetch(`${endpoint}/channels`, {
          method: "POST",
          headers: buildHeaders(),
          body: JSON.stringify({ channels: channelsObj }),
        });
        const data = await resp.json();
        if (!resp.ok) throw new Error(data.detail || JSON.stringify(data));
        upstreamChannels = channelsObj;
        renderChannels();
        // 渠道更新后，后端可能已清理某些渠道的别名，这里重新拉取一次配置和模型
        await fetchOverrides();
        await fetchModels();
      }

      function currentModelsChannel() {
        return modelsChannelFilter.value || "";
      }

      function renderModelList(list) {
        modelsBox.textContent = "";
        if (!list || !list.length) {
          modelsBox.textContent = "暂无模型，请确认上游配置是否正确。";
          return;
        }

        const groups = {};
        list.forEach((item) => {
          if (!item || typeof item !== "object") return;
          const ch = (item.metadata && item.metadata.channel) || "默认/未指定";
          const key = `${ch}::${item.id}`;
          if (hiddenModels.has(key)) return;
          if (!groups[ch]) groups[ch] = [];
          groups[ch].push(item);
        });

        Object.entries(groups).forEach(([ch, items]) => {
          const header = document.createElement("div");
          header.className = "note";
          header.textContent = `渠道：${ch}`;
          modelsBox.appendChild(header);

          items.forEach((item) => {
            const row = document.createElement("div");
            row.className = "model-row";

            const btn = document.createElement("button");
            btn.type = "button";
            btn.className = "model-item";
            const isAlias = item.owned_by === "proxy-override";
            if (isAlias) btn.classList.add("alias");
            btn.dataset.modelId = item.id;

            const main = document.createElement("span");
            main.textContent = item.id;

            const meta = document.createElement("span");
            meta.className = "meta";
            const metaParts = [];
            if (item.alias_for) metaParts.push(`→ ${item.alias_for}`);
            if (item.metadata && item.metadata.channel)
              metaParts.push(`渠道=${item.metadata.channel}`);
            meta.textContent = metaParts.join(" · ");

            btn.appendChild(main);
            btn.appendChild(meta);
            btn.onclick = () => openSettings(item.id, item);
            row.appendChild(btn);

            const delBtn = document.createElement("button");
            delBtn.type = "button";
            delBtn.className = "danger";
            delBtn.textContent = isAlias ? "删别名" : "隐藏";
            delBtn.onclick = async (ev) => {
              ev.stopPropagation();
              if (isAlias) {
                await deleteAliasById(item.id);
              } else {
                const key = `${ch}::${item.id}`;
                hiddenModels.add(key);
                saveHiddenModels();
                renderModelList(modelsCache);
                setStatus(`已从列表隐藏模型 ${item.id}（渠道=${ch}）`);
              }
            };
            row.appendChild(delBtn);

            modelsBox.appendChild(row);
          });
        });
      }

      async function fetchModels() {
        const endpoint = currentEndpoint();
        const ch = currentModelsChannel();
        let url = `${endpoint}/v1/models`;
        if (ch) {
          url += `?channel=${encodeURIComponent(ch)}`;
        }
        setStatus("正在拉取模型列表...");
        try {
          const resp = await fetch(url, { headers: buildHeaders() });
          const data = await resp.json();
          if (!resp.ok) throw new Error(JSON.stringify(data));
          modelsCache = data.data || [];
          renderModelList(modelsCache);
          setStatus("模型列表已更新，点击模型可编辑覆写设置。");
        } catch (err) {
          modelsBox.textContent = "获取失败";
          setStatus(`拉取模型失败：${err}`);
        }
      }

      function updateSettingsLine() {
        const aliasId = settingsModelId.value.trim();
        if (!aliasId) {
          currentSettingsLine.textContent = "未选择模型";
          return;
        }
        const targetModel = settingsTargetModel.value.trim() || aliasId;
        const channel = settingsChannel.value.trim();
        const baseInfo = currentBaseModelId ? `上游参考=${currentBaseModelId}` : "上游参考=未选择";
        const targetInfo =
          targetModel === aliasId
            ? "未配置重定向（上游模型与别名相同）"
            : `重定向到上游模型=${targetModel}`;
        const channelInfo = channel ? `渠道=${channel}` : "渠道未设";
        currentSettingsLine.textContent = `别名模型=${aliasId} · ${targetInfo} · ${channelInfo} · ${baseInfo}`;
      }

      function renderConfigPreview() {
        const cfg = {};
        Object.entries(modelSettings).forEach(([id, item]) => {
          cfg[id] = {
            target_model: item.targetModel || id,
            channel: item.channel || undefined,
          };
        });
        configPreview.value = JSON.stringify(cfg, null, 2);
      }

      async function fetchOverrides() {
        const endpoint = currentEndpoint();
        try {
          const resp = await fetch(`${endpoint}/overrides`, { headers: buildHeaders() });
          const data = await resp.json();
          if (!resp.ok) throw new Error(JSON.stringify(data));
          modelSettings = {};
          Object.entries(data || {}).forEach(([mid, cfg]) => {
            modelSettings[mid] = {
              targetModel: cfg.target_model || mid,
              channel: cfg.channel || "",
            };
          });
          renderConfigPreview();
          updateSettingsLine();
          setStatus("覆写配置已同步。");
        } catch (err) {
          setStatus(`获取覆写配置失败：${err}`);
        }
      }

      async function persistOverrides() {
        const endpoint = currentEndpoint();
        const payload = {};
        Object.entries(modelSettings).forEach(([mid, item]) => {
          payload[mid] = {
            target_model: item.targetModel || mid,
            channel: item.channel || undefined,
          };
        });
        const resp = await fetch(`${endpoint}/overrides`, {
          method: "POST",
          headers: buildHeaders(),
          body: JSON.stringify(payload),
        });
        const data = await resp.json();
        if (!resp.ok) throw new Error(data.detail || JSON.stringify(data));
        setStatus(`覆写配置已持久化（共 ${data.count} 条）。`);
      }

      function openSettings(modelId, modelObj) {
        currentEditingModelId = modelId;
        currentBaseModelId = (modelObj && (modelObj.alias_for || modelObj.id)) || "";
        settingsModelId.value = modelId;
        const cfg = modelSettings[modelId] || {};
        settingsTargetModel.value = cfg.targetModel || currentBaseModelId || modelId;
        settingsChannel.value =
          cfg.channel || (modelObj && modelObj.metadata && modelObj.metadata.channel) || "";
        updateSettingsLine();

        Array.from(modelsBox.querySelectorAll(".model-item")).forEach((btn) => {
          if (btn.dataset.modelId === modelId) btn.classList.add("active");
          else btn.classList.remove("active");
        });
      }

      async function saveSettings() {
        const modelId = settingsModelId.value.trim();
        if (!modelId) {
          setStatus("请先填写“客户端模型 ID（别名）”。");
          return;
        }
        const targetModel = settingsTargetModel.value.trim();
        const channel = settingsChannel.value.trim();
        if (!targetModel) {
          setStatus("请填写“目标模型 ID（上游实际模型名）”。");
          return;
        }
        if (!channel) {
          setStatus("请先选择渠道，别名需要与渠道成对绑定。");
          return;
        }

        if (currentEditingModelId && currentEditingModelId !== modelId) {
          delete modelSettings[currentEditingModelId];
          currentEditingModelId = modelId;
        }

        modelSettings[modelId] = {
          targetModel,
          channel,
        };
        updateSettingsLine();
        renderConfigPreview();
        try {
          await persistOverrides();
          await fetchModels();
        } catch (err) {
          setStatus(`保存覆写到服务端失败：${err}`);
          return;
        }
        setStatus(`已保存模型 ${modelId} 的覆写设置并同步到服务端。`);
      }

      async function deleteAliasById(aliasId) {
        if (!modelSettings[aliasId]) {
          setStatus(`别名 ${aliasId} 在配置中不存在，无需删除。`);
          return;
        }
        delete modelSettings[aliasId];
        renderConfigPreview();
        if (settingsModelId.value.trim() === aliasId) {
          settingsModelId.value = "";
          settingsTargetModel.value = "";
          settingsChannel.value = "";
          currentEditingModelId = "";
          currentBaseModelId = "";
          updateSettingsLine();
        }
        try {
          await persistOverrides();
          await fetchModels();
        } catch (err) {
          setStatus(`删除别名失败：${err}`);
          return;
        }
        setStatus(`别名 ${aliasId} 已从覆写配置中删除并同步到服务端。`);
      }

      function newAlias() {
        currentEditingModelId = "";
        currentBaseModelId = "";
        settingsModelId.value = "";
        settingsTargetModel.value = "";
        settingsChannel.value = "";
        updateSettingsLine();
      }

      async function deleteAlias() {
        const aliasId = settingsModelId.value.trim();
        if (!aliasId) {
          setStatus("请先选择或填写要删除的别名。");
          return;
        }
        await deleteAliasById(aliasId);
      }

      refreshModelsBtn.onclick = () => {
        saveEndpointAndKey();
        fetchModels();
      };
      reloadConfigBtn.onclick = () => {
        saveEndpointAndKey();
        fetchOverrides();
        fetchChannels();
      };
      saveSettingsBtn.onclick = saveSettings;
      newAliasBtn.onclick = newAlias;
      deleteAliasBtn.onclick = deleteAlias;
      modelsChannelFilter.onchange = () => {
        fetchModels();
      };

      addChannelBtn.onclick = async () => {
        const name = newChannelName.value.trim();
        const baseUrl = newChannelBaseUrl.value.trim();
        const apiKey = newChannelKey.value.trim();
        if (!name || !baseUrl || !apiKey) {
          setStatus("请完整填写渠道名称、地址和密钥。");
          return;
        }
        const next = { ...(upstreamChannels || {}) };
        next[name] = { base_url: baseUrl, api_key: apiKey };
        try {
          await saveChannelsToServer(next);
        } catch (err) {
          setStatus(`保存渠道失败：${err}`);
          return;
        }
        newChannelName.value = "";
        newChannelBaseUrl.value = "";
        newChannelKey.value = "";
        setStatus(`渠道 ${name} 已更新并同步到 .env（UPSTREAM_CHANNELS）。`);
      };

      (async function init() {
        hydrateEndpointAndKey();
        loadHiddenModels();
        await fetchChannels();
        await fetchOverrides();
        await fetchModels();
      })();
    </script>
  </body>
</html>

